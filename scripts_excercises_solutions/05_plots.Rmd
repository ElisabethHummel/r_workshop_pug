---
title: "05 Plots"
output: 
  html_document:
    theme: dark
    highlight: zenburn
    df_print: paged
---

```{css, echo=FALSE}
.dark-output {
  background-color: #5a5a5a;
    color: white;
}

.error-output {
  background-color: #cc9393;
    color: black;
}

.message-output {
  background-color: #5a5a5a;
    color: white;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, class.output = "dark-output", class.error = "error-output",
  class.message = "message-output", fig.align = "center"
)
```

## Now for some fun

There is more to be said about data wrangling, and we will get back to it, but I want to create some plots first.
Plots are fun because they give you nice and colourful results, and they are a very important tool for inspecting your data and getting an intuition for it.
While base `R` has a plotting function, the `tidyverse`'s `ggplot2` is what is partly responsible for `R`'s fame.

`ggplot2` is based on the ["Grammar of Graphics" by Leland Wilkinson](https://www.springer.com/de/book/9780387245447), a framework for good data visualisation in data science.
In a way, `ggplot2` has a grammar of its own, which is something new for us.
But don't worry, it all makes sense.

## Call other scripts

First, we need some data.
If the data from previous exercises is still in your environment, use this opportunity to clear your workspace using `rm(list = ls())`.
We want to start with a clean slate.
However, the work we did in the previous data wrangling script should not go to waste.
We don't need to run all our code in the same script - in fact, it's good practice to distribute your code across several scripts so you know where to find what.
The preprocessing could e.g. go into one script, the analysis into another one and then you could have a separate script for plots or tables.
Here, we want to run the preprocessing we did in the data wrangling script (excluding participants with implausible values etc.) and then work with the clean data in this script.
However, we don't want to run the whole file with all exercises in it - we only need the relevant preprocessing steps.
Also, we don't want to render the whole R Markdown file - we just want the preprocessing to run in the background.
I put the relevant preprocessing steps into a script called "nerd_preprocessing.R".
You can find it in the same folder as this R Markdown file.
Take a moment to look at the individual steps in the preprocessing file before you continue.

We call our preprocessing script using the function `source()`.
It runs the file that you named in the first argument (don't forget the file extension ".R").
Open your environment tab in the top right corner of RStudio and then run the following code cell.
In your empty environment, the variables `nerd` and `nerd_red` should appear.

```{r}
library(tidyverse)
source("nerd_preprocessing.R")
```

## Simple plots

One basic plot that you will frequently need is a histogram.
It's a good way to quickly inspect the distribution of your data.
Below, you see how a simple histogram for the participant age works.
The concept is pretty simple: We pipe our data, `nerd_red` into the `ggplot()` function.
Within the function, we use the `aes()` function, which stands for "aesthetics".
The aesthetic function is used to tell `ggplot()` all the information that is related to the data (as opposed to things that have nothing to do with the data, e.g. overall plot colour).
It will make more sense once we see which things belong into `aes()` and which things belong outside of it.
Unsurprisingly, the argument `x` is what we want to put on the x-axis, which is the age of our participants in this case.
Lastly, we tell `ggplot()` to make a histogram from our data.
Ggplot uses different "geoms", which you can imagine as different "geometric" plot shapes.
Other geoms are for example `geom_point`, `geom_bar` or `geom_boxplot`.
You can probably guess what they do.
The special thing is that we don't use a pipe to add the histogram, but a plus sign.
That is because `ggplot()` works with "layers".
It's a bit like using PowerPoint: When you created a slide, some elements are behind/in front of each other.
In `ggplot2`, it's the same principle.
Here, we already use two layers: The plot background as first layer, and then there's our histogram on top of that.

```{r}
nerd_red %>% 
  ggplot(aes(x = age)) +
  geom_histogram(bins = 30)
```

We can observe the layered structure by leaving out the histogram layer.
Here, we can see that `ggplot()` still drew the plot background for us.
It also labelled the x-axis with "age", because it knows that our age data will go there.
Furthermore, it picked a sensible scale for the axis, because it knows the minimum/maximum of our data and can figure out the range it will need to plot.
However, no data is plotted, and there is no y-axis, because did not provide any information for the y-axis.
In our previous plot, `geom_histogram` automatically counted how many participants were in each age bin, and based the y-axis on that.

```{r}
nerd_red %>% 
  ggplot(aes(x = age))
```

Let's check out a different geom.
Try `geom_boxplot()`.
It looks a bit weird - what might be the problem here?

```{r}
nerd_red %>% 
  ggplot(aes(x = age)) +
  geom_boxplot()
```

The plot will look much better with a different orientation, i.e. the data on the y-axis.

```{r}
nerd_red %>% 
  ggplot(aes(y = age)) +
  geom_boxplot()
```

But still, the x-axis looks weird.
Here's how we can fix that: We'll add a "dummy" for the x-axis so the ticks will be blank.
There's still that nasty little x as axis label - we'll talk about how to get rid of that later.

```{r}
nerd_red %>% 
  ggplot(aes(y = age, x = "")) +
  geom_boxplot()
```

For now, let's try another geom.
How about a good old scatter plot?
For this, we need some information on the x **and** y axis.
What do we want to plot on next to age?
Maybe the nerd score?

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score)) +
  geom_point()
```

When we think about scatter plots, we usually think about regression lines.
How about adding a line to the data, indicating how age and nerd score are associated with each other?
The corresponding geom is called `geom_smooth`.

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score)) +
  geom_point() +
  geom_smooth()
```

The default method for `geom_smooth`, as `R` informs us, is "loess".
It "[fits] a polynomial surface determined by one or more numerical predictors, using local fitting." (Run`?loess` in the console for more information.)
You see that it does not produce a straight line - if we want a plain linear regression, we have to set the argument `method` to `"lm"`.
With the argument `se = FALSE` we can get rid of the grey confidence interval around the data. 

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

## Building plots

It is worth pointing out that you can a) save plots into variables just like anything else and b) that you can expand them bit by bit, i.e. you don't have to copy-paste the whole code of the plot over and over again whenever you change something (like I do in this script).

Here, we save the scatter plot from before into a variable:

```{r}
my_scatter_plot <- 
  nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score)) +
  geom_point()
```

... and call it here:

```{r}
my_scatter_plot
```

We can add the regression line to our existing plot like this:

```{r}
my_scatter_plot +
  geom_smooth(method = "lm", se = FALSE)
```

Note that `my_scatter_plot` still contains only the scatter plot, without the regression line, because I did not overwrite it.

So while it would be entirely possible to modify only parts of the plot without having to recycle the code from before, I will always give you the whole code for each plot in this script.
In my opinion, that makes it easier to understand how the plot was made, because nothing is hidden away in a variable.
My usual workflow is to build my plots step by step, and I save them into variables once I'm done.

## Adding more complexity

Would you like to know how the relation between age and nerd score looks like for different subgroups of your data?
We can easily split our plot by another variable, e.g. gender.
Because gender is a property of our data, so it also goes into the `aes()` function.

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

## Customise things

This is all fun and games, but let's be honest, this plot is ugly.
We want to customise it a little bit.
For example, the text on the y axis says "nerd_score", because `ggplot()` just put in the name of the column we told it to put on the y-axis.
We can change that using `labs()`, which we can use to control the labels of our plot.
(Try the arguments `x`, `title` or `subtitle`.)

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(y = "nerd score")
```

Next, let's move the legend to the top of the plot.
Using `theme()`, we can control **a lot** of things in our plot, like font sizes, whether there should be grid lines or not and much, much more.

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(y = "nerd score") +
  theme(legend.position = "top")
```

This grey plot grid is something `ggplot2` is very famous for.
However, it might not be the most beautiful and modern plotting option.
You can either set up a completely custom theme by manually customising all aspects of your plot using the `theme()` function, or you can use one of the many default themes, for example the classic theme.
You can find a list of themes [here](https://ggplot2.tidyverse.org/reference/ggtheme.html).

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(y = "nerd score") +
  theme_classic() +
  theme(legend.position = "top") 
```

Note that we have to put in `theme(legend.position = "top")` after `theme_classic()`, because in `theme_classic()`, the legend is on the right side of the plot.
If we use `theme(legend.position = "top")` first, it gets overwritten by `theme_classic()`:

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(y = "nerd score") +
  theme(legend.position = "top") +
  theme_classic()
```

## Axis steps

Our plot looks much better now. How about more fine-grained steps on the x and y axis?
One quick way to set up the breaks on a plot axis is the function `seq()`.
It generates a sequence of numbers.
You give it the start point, the end point, and the stepsize:

```{r}
# A sequence from 1 - 10 in steps of 2
seq(1, 10, 2)
```

It is also possible not to give a step size, but the **number** of steps (i.e. the length of the output) instead:

```{r}
seq(1, 10, length.out = 3)
```

Now we can use `seq()` to adjust our axes like this:

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  
  scale_x_continuous(breaks = seq(10, 90, 10), limits = c(10, 90)) +
  scale_y_continuous(breaks = seq(0, 130, 20)) +
  
  labs(y = "nerd score") +
  theme_classic() +
  theme(legend.position = "top")
```

# Geom appearance

How about some thicker lines for the regression lines?
And maybe we should make the dots a bit more opaque.
Note that all of these things don't go inside the `aes()` function, because things like transparency or line size don't depend on the data.
It is just something that we apply to all data points, irrespective of the underlying data structure.

```{r}
# use alpha and size outside of the aes function!
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, colour = gender)) +
  geom_point(alpha = .4, size = 2) +
  geom_smooth(method = "lm", se = FALSE, size = 1.5) +
  
  scale_x_continuous(breaks = seq(10, 90, 10), limits = c(10, 90)) +
  scale_y_continuous(breaks = seq(0, 130, 20)) +
  
  labs(y = "nerd score") +
  theme_classic() +
  theme(legend.position = "top")
```

Let's test our new skills and make our first histogram from before a little bit more beautiful.
Here is what it looked like before:

```{r}
nerd_red %>% 
  ggplot(aes(x = age)) +
  geom_histogram()
```

Let's change the theme and also add some colour.
Note that some for some geoms or shapes, there is a distinction between `colour` and `fill`.
Fill does exactly what the name suggests, and colour usually refers to the colour of the border.
We can refer to the colour that we want by name (i.e. "black", or "dark red" - find a full list [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)), but can also use hex codes.

```{r}
nerd_red %>% 
  ggplot(aes(x = age)) +
  geom_histogram(fill = "#dca3a3", colour = "black") +
  theme_classic()
```

You might be a bit confused now, because for our previous scatter plot, we used colour to change the colour of the circles, not of the **border** of the circles.
That is because the circles we used before don't have a border - or rather, they only consist of a border.
There are several different shapes that we can use in our scatter plot, and we address them by different numbers using the `shape` argument.
[Here](http://www.sthda.com/english/wiki/ggplot2-point-shapes) is a list of all available shapes.
Shapes 21 - 25 respond to `colour` **and** `fill`.

Here is the same scatter plot as above, but using shape number 25 with the colour black.
Note that we now use `fill = gender` instead of `colour = gender`!

```{r}
# Shape doesn't have anything to do with our data, so it goes outside of
# the aes function!
# (I also increased alpha a bit)
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, fill = gender)) +
  geom_point(alpha = .7, size = 2, shape = 25, colour = "black") +
  geom_smooth(method = "lm", se = FALSE, size = 1.5) +
  
  scale_x_continuous(breaks = seq(10, 90, 10), limits = c(10, 90)) +
  scale_y_continuous(breaks = seq(0, 130, 20)) +
  
  labs(y = "nerd score") +
  theme_classic() +
  theme(legend.position = "top")
```

Woops. Because we changed `colour = gender` to `fill = gender`, the regression lines are not coloured anymore.
We add `colour = gender` back to our `ggplot()` function.
The interesting thing is that the colour of the triangles (i.e. the colour of their border) is not affected by this.
`colour = "black"` comes after the `ggplot()` function, so `colour = gender` is overwritten for `geom_point()`.
You can try to leave out `colour = "black"` and observe what happens.

```{r}
nerd_red %>% 
  ggplot(aes(x = age, y = nerd_score, fill = gender, colour = gender)) +
  geom_point(alpha = .7, size = 2, shape = 25, colour = "black") +
  geom_smooth(method = "lm", se = FALSE, size = 1.5) +
  
  scale_x_continuous(breaks = seq(10, 90, 10), limits = c(10, 90)) +
  scale_y_continuous(breaks = seq(0, 130, 20)) +
  
  labs(y = "nerd score") +
  theme_classic() +
  theme(legend.position = "top")
```





How about categorical data?
Let's have a boxplot for age that is grouped by gender.
Here, I use gender on both the x-axis and for the colour.
That's a bit redundant, but we can hide the x-axis if we want, so only the legend carries the information.
I have also added a title.

```{r}
# create a box plot with y = age and x = gender.
# fill by gender
# set a title
# use a nice theme and move the legend to the top
nerd_red %>% 
  ggplot(aes(x = gender, y = age, fill = gender)) +
  geom_boxplot() +
  labs(title = "age by gender") +
  theme_bw() +
  theme(
    legend.position = "top",
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```

How about adding another factor?

1.1) Can you do a boxplot that has the nerd score on the y-axis, gender on the x-axis and is filled with whether the person voted or not?

```{r}
nerd_red %>% 
  ggplot(aes(x = gender, y = nerd_score, fill = voted)) +
  geom_boxplot() +
  scale_fill_manual("did people vote", values = c("pink", "blue3")) +
  theme_bw() +
  theme(legend.position = "top")
```

## Detour: Long format

What if we wanted do a boxplot for each of the nerdy items, `Q1` - `Q2` next to each other?
We run into a problem: Each item is stored in a separate column, but we can only put **one** column on the x-axis.
That is because `ggplot2` (and in fact, a lot of `tidyverse` functions) require the "long format".
The long format means that we deviate from the classical data format where every participant has a single row.
In the long format, one participant can take up several rows.
Consider this simplified example of a data frame with two participants and three items:

```{r}
wide_format <- 
  data.frame(
    participant = 1:2,
    item_1 = c(1, 4),
    item_2 = c(5, 10),
    item_3 = c(11, 2)
  )

wide_format
```

We want to "pivot" the data, so we end up with a situation like this (only observe the output for now, not the code):

```{r}
wide_format %>% 
  pivot_longer(
    item_1:item_3,
    names_to = "item",
    values_to = "score"
  )
```

As you can see, each participant now takes up three rows (one for each item), and the corresponding score is stored in a single, separate column.
This would now e.g. allow us to build a plot where we put the item on the x-axis and the score on the y-axis.

You may know this transformation from other programmes like SPSS.
In the `tidyverse`, we achieve this by using the `pivot_longer()` function.
Here is how it works: First, we tell it which columns should be part of the pivot, in our case, `item1` - `item3`.
You may think: Wait a minute. But the whole data frame is being transformed, aren't all columns part of the pivot?
Think of it like this: We provide the columns that should be gone in the resulting "long" data frame, and replaced by other columns.
In our case, we want to get rid of the individual item columns, but turn them into a column coding which item we have and a corresponding score column.
Next, we use the argument `names_to` to name our "naming" column.
This column will hold the old column names.
And lastly, we use the argument `values_to` to name the column that holds the values that were previously scored in the three different item columns.

`pivot_longer()` is a very powerful function that can handle much more complicated cases where multiple columns are turned into multiple naming columns, but this does not concern us for now.
However, one handy trick is to clean up the naming column a little bit:

```{r}
wide_format %>% 
  pivot_longer(
    item_1:item_3,
    names_to = "item",
    values_to = "score",
    names_prefix = "item_"
  )
```

Let's practice this a little bit.

1.2) Select the items from the Ten Item Personality Inventory from the `nerd` data (**not** `nerd_red`!). Those are named `TIPI1` - `TIPI10`. Also store the `age` column and create a column with a participant id. Save the resulting data frame into a new variable. Then, pivot the data into the long format, with a column called `TIPI_item` that stores the item name, and a column called `score` that stores the participants' response.

```{r}
# Select the age column and the items from the Ten Item Personality Inventory from the `nerd` data 
# (**not** `nerd_red`!). Those are named `TIPI1` - `TIPI10`.
# Create a column with a participant id.
# Save the resulting data frame into a new variable.
# Then, pivot the data into the long format, with a column called `TIPI_item` that stores the 
# item name, and a column called `score` that stores the participants' response.
```

1.3) Now back to our initial plan. Take `nerd_red` and transform it into the long format in such a way that you end up with a column storing the nerd item name (`Q1`- `Q26`) and another column storing the response to each item.

1.4) Create a boxplot with each nerd item on the x-axis and the score on the y-axis.

## Free solo

Now it's time to brain storm some plot ideas together.
Which plots do you want to see?
You suggest a plot, and then we will discuss together how we can build that plot.

**THIS IS A GITHUB PUSH CHECKPOINT**
